<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å‘ç¥¨å›¾ç‰‡å¯¼å‡ºå™¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .controls {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(86, 171, 47, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ff9a56 0%, #ff6b6b 100%);
            color: white;
        }

        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 154, 86, 0.4);
        }

        .btn-info {
            background: linear-gradient(135deg, #17a2b8 0%, #6f42c1 100%);
            color: white;
        }

        .btn-info:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(23, 162, 184, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .canvas-container {
            padding: 30px;
            display: flex;
            justify-content: center;
            background: #f8f9fa;
        }

        #canvas {
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            background: white;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            image-rendering: high-quality;
            max-width: 100%;
            height: auto;
        }

        .status {
            padding: 20px 30px;
            text-align: center;
            font-size: 16px;
            color: #666;
        }

        .status.success {
            color: #28a745;
            background: #d4edda;
            border-radius: 8px;
            margin: 0 30px 30px 30px;
        }

        .status.error {
            color: #dc3545;
            background: #f8d7da;
            border-radius: 8px;
            margin: 0 30px 30px 30px;
        }

        .image-info {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
            display: none;
        }

        .image-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            text-align: center;
            min-width: 150px;
        }

        .image-item img {
            max-width: 100px;
            max-height: 60px;
            object-fit: contain;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .image-item p {
            font-size: 12px;
            color: #666;
            margin: 5px 0;
        }

        .quality-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .quality-selector label {
            font-weight: 600;
            color: #333;
        }

        .quality-selector select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        .quality-selector select:focus {
            outline: none;
            border-color: #667eea;
        }

        .quality-selector input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .quality-info {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            .button-group {
                flex-direction: column;
                align-items: center;
            }
            
            .btn {
                width: 100%;
                max-width: 300px;
            }
        }

        /* æ‰“å°æ ·å¼ */
        @media print {
            @page {
                margin: 0 !important;
                size: A4 !important;
            }
            
            body {
                background: white !important;
                padding: 0 !important;
                margin: 0 !important;
            }
            
            .container {
                box-shadow: none !important;
                border-radius: 0 !important;
                max-width: none !important;
                margin: 0 !important;
                padding: 0 !important;
            }
            
            .header,
            .controls,
            .status {
                display: none !important;
            }
            
            .canvas-container {
                padding: 0 !important;
                background: white !important;
                margin: 0 !important;
            }
            
            #canvas {
                border: none !important;
                box-shadow: none !important;
                width: 100% !important;
                height: auto !important;
                margin: 0 !important;
                padding: 0 !important;
            }
            
            /* ç¡®ä¿å‘ç¥¨é—´éš”å’Œé»‘çº¿åœ¨æ‰“å°æ—¶æ­£ç¡®æ˜¾ç¤º */
            .invoice-separator {
                background: white !important;
                height: 20px !important;
                width: 100% !important;
                border-bottom: 3px solid black !important;
            }
        }
        
        /* è¿›åº¦æ¡æ ·å¼ */
        .progress-container {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .progress-text {
            font-size: 14px;
            color: #666;
            text-align: center;
            font-weight: 500;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“„ æ–‡ä»¶å¯¼å‡ºå™¨</h1>
            <p>ä¸Šä¼ å›¾ç‰‡æˆ–PDFæ–‡ä»¶ï¼Œè‡ªåŠ¨æ’ç‰ˆä¸ºA4å°ºå¯¸å¹¶å¯¼å‡º</p>
        </div>

        <div class="controls">
            <div class="button-group">
                <input type="file" id="mainFileInput" accept="image/*,.pdf" multiple style="display: none;">
                <input type="file" id="imageInput" accept="image/*" multiple style="display: none;">
                <input type="file" id="pdfInput" accept="application/pdf" multiple style="display: none;">
                <button class="btn btn-primary" onclick="document.getElementById('mainFileInput').click()">
                    ğŸ“ é€‰æ‹©åˆå§‹æ–‡ä»¶
                </button>
                <button class="btn btn-success" onclick="document.getElementById('imageInput').click()">
                    â• ç»­åŠ å›¾ç‰‡
                </button>
                <button class="btn btn-success" onclick="document.getElementById('pdfInput').click()">
                    ğŸ“„ ç»­åŠ PDF
                </button>
                <button class="btn btn-primary" id="exportBtn" onclick="exportImage()" disabled>
                    ğŸ’¾ å¯¼å‡ºå›¾ç‰‡
                </button>

                <button class="btn btn-info" id="previewBtn" onclick="previewPrint()" disabled>
                    ğŸ‘ï¸ æ‰“å°é¢„è§ˆ
                </button>
                <button class="btn btn-warning" onclick="clearCanvas()">
                    ğŸ—‘ï¸ æ¸…ç©ºç”»å¸ƒ
                </button>
                <button class="btn btn-primary" id="reprocessBtn" onclick="reprocessPDF()" style="display: none;">
                    ğŸ”„ é‡æ–°æ¸²æŸ“PDF
                </button>
                <div class="pagination-controls" style="display: none; margin-top: 15px; text-align: center;"
                    id="paginationControls">
                    <button class="btn btn-info" onclick="prevPage()" id="prevPageBtn" disabled>
                        â—€ï¸ ä¸Šä¸€é¡µ
                    </button>
                    <span style="margin: 0 15px; font-weight: bold;" id="pageInfo">ç¬¬ 1 é¡µ / å…± 1 é¡µ</span>
                    <button class="btn btn-info" onclick="nextPage()" id="nextPageBtn" disabled>
                        ä¸‹ä¸€é¡µ â–¶ï¸
                </button>
                </div>
            </div>
            <div class="image-info" id="imageInfo"></div>
            <div class="quality-selector">
                <label for="pdfQuality">PDFæ¸²æŸ“è´¨é‡:</label>
                <select id="pdfQuality">
                    <option value="2.0">æ ‡å‡† (2x)</option>
                    <option value="3.0">é«˜æ¸… (3x)</option>
                    <option value="4.0" selected>è¶…æ¸… (4x)</option>
                    <option value="6.0">ææ¸… (6x)</option>
                    <option value="8.0">æœ€é«˜ (8x)</option>
                </select>
                <div class="quality-info" id="qualityInfo">å½“å‰è´¨é‡: 4x</div>
            </div>
            <div class="quality-selector">
                <label for="autoCrop">è‡ªåŠ¨è£å‰ªç©ºç™½:</label>
                <input type="checkbox" id="autoCrop" checked>
                <div class="quality-info">è‡ªåŠ¨æ£€æµ‹å¹¶è£å‰ªPDFä¸­çš„ç©ºç™½åŒºåŸŸï¼ˆæŸäº›å‘ç¥¨å¯èƒ½éœ€è¦å…³é—­æ­¤é€‰é¡¹ï¼‰</div>
            </div>
            <div class="quality-selector">
                <button class="btn btn-info" onclick="toggleDebugMode()" style="padding: 8px 16px; font-size: 14px;">
                    ğŸ› è°ƒè¯•æ¨¡å¼
                </button>
                <div class="quality-info">å¼€å¯åå¯åœ¨æ§åˆ¶å°æŸ¥çœ‹è¯¦ç»†çš„æ£€æµ‹ä¿¡æ¯</div>
            </div>
            <div class="quality-selector">
                <button class="btn btn-warning" onclick="clearCache()" style="padding: 8px 16px; font-size: 14px;">
                    ğŸ—‘ï¸ æ¸…ç†ç¼“å­˜
                </button>
                <div class="quality-info">æ¸…ç†PDFç¼“å­˜å’Œé‡Šæ”¾å†…å­˜</div>
            </div>
            <div class="progress-container" id="progressContainer" style="display: none; margin: 15px 0;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
                </div>
                <div class="progress-text" id="progressText">å¤„ç†ä¸­...</div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="canvas" width="2480" height="3508"></canvas>
        </div>

        <div class="status" id="status"></div>
    </div>

    <script>
        // A4å°ºå¯¸è®¾ç½® (21cm x 29.7cm, 300 DPI é«˜æ¸…)
        const A4_WIDTH = 2480;  // 21cm * 300 DPI / 2.54
        const A4_HEIGHT = 3508; // 29.7cm * 300 DPI / 2.54
        const SECTION_HEIGHT = A4_HEIGHT / 3; // æ¯å¼ å›¾ç‰‡çš„é«˜åº¦
        const INVOICE_SPACING = 20; // å‘ç¥¨ä¹‹é—´çš„é—´éš”è·ç¦»ï¼ˆåƒç´ ï¼‰
        const INVOICE_LINE_HEIGHT = 3; // åˆ†éš”çº¿é«˜åº¦ï¼ˆåƒç´ ï¼‰
        const MAX_IMAGES_PER_PAGE = 3; // æ¯é¡µæœ€å¤šå›¾ç‰‡æ•°é‡
        const MAX_PAGES = 10; // æœ€å¤šé¡µæ•°é™åˆ¶
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const mainFileInput = document.getElementById('mainFileInput');
        const imageInput = document.getElementById('imageInput');
        const pdfInput = document.getElementById('pdfInput');
        const exportBtn = document.getElementById('exportBtn');

        const previewBtn = document.getElementById('previewBtn');
        const status = document.getElementById('status');
        const imageInfo = document.getElementById('imageInfo');
        const pdfQualitySelect = document.getElementById('pdfQuality');
        const qualityInfo = document.getElementById('qualityInfo');

        // è·å–å½“å‰PDFæ¸²æŸ“è´¨é‡
        function getPdfRenderScale() {
            return parseFloat(pdfQualitySelect.value);
        }

        // è·å–æ˜¯å¦å¯ç”¨è‡ªåŠ¨è£å‰ª
        function isAutoCropEnabled() {
            return document.getElementById('autoCrop').checked;
        }

        // åˆ‡æ¢è°ƒè¯•æ¨¡å¼
        function toggleDebugMode() {
            debugMode = !debugMode;
            if (debugMode) {
                showStatus('è°ƒè¯•æ¨¡å¼å·²å¼€å¯ï¼Œè¯·æŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°', 'info');
                console.log('=== å‘ç¥¨æ£€æµ‹è°ƒè¯•æ¨¡å¼å·²å¼€å¯ ===');
                console.log('å°†æ˜¾ç¤ºè¯¦ç»†çš„PDFå¤„ç†å’Œå†…å®¹æ£€æµ‹ä¿¡æ¯');
            } else {
                showStatus('è°ƒè¯•æ¨¡å¼å·²å…³é—­', 'info');
                console.log('=== å‘ç¥¨æ£€æµ‹è°ƒè¯•æ¨¡å¼å·²å…³é—­ ===');
            }
        }
        
        // è¿›åº¦æ¡ç®¡ç†
        const progressBar = {
            container: document.getElementById('progressContainer'),
            fill: document.getElementById('progressFill'),
            text: document.getElementById('progressText'),
            
            show() {
                this.container.style.display = 'block';
            },
            
            hide() {
                this.container.style.display = 'none';
            },
            
            update(percent, message) {
                this.fill.style.width = percent + '%';
                this.text.textContent = message;
            },
            
            increment(increment, message) {
                const currentWidth = parseFloat(this.fill.style.width) || 0;
                const newWidth = Math.min(100, currentWidth + increment);
                this.update(newWidth, message);
            }
        };
        
        // é˜²æŠ–å‡½æ•°
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // æ¸…ç†ç¼“å­˜
        function clearCache() {
            performanceMonitor.start('ç¼“å­˜æ¸…ç†');
            
            // æ¸…ç†PDFç¼“å­˜
            pdfCache.clear();
            
            // æ¸…ç†å›¾ç‰‡ç¼“å­˜
            memoryManager.clearImageCache();
            
            // ä¼˜åŒ–canvas
            memoryManager.optimizeCanvas();
            
            // å¼ºåˆ¶åƒåœ¾å›æ”¶
            performanceMonitor.cleanup();
            
            // æ£€æŸ¥å†…å­˜
            const memory = performanceMonitor.checkMemory();
            
            performanceMonitor.end('ç¼“å­˜æ¸…ç†');
            
            showStatus(`ç¼“å­˜æ¸…ç†å®Œæˆï¼Œå½“å‰å†…å­˜ä½¿ç”¨: ${memory ? memory.used + 'MB' : 'æœªçŸ¥'}`, 'success');
            
            if (debugMode) {
                console.log('ğŸ§¹ ç¼“å­˜æ¸…ç†å®Œæˆ');
            }
        }
        
        // ä¼˜åŒ–çš„çŠ¶æ€æ˜¾ç¤ºï¼ˆé˜²æŠ–ï¼‰
        const debouncedShowStatus = debounce((message, type = 'info') => {
            showStatus(message, type);
        }, 100);

        // æ›´æ–°è´¨é‡ä¿¡æ¯æ˜¾ç¤º
        function updateQualityInfo() {
            const scale = getPdfRenderScale();
            qualityInfo.textContent = `å½“å‰è´¨é‡: ${scale}x`;
        }

        // ç›‘å¬è´¨é‡é€‰æ‹©å˜åŒ–
        pdfQualitySelect.addEventListener('change', updateQualityInfo);

        let uploadedImages = [];
        let uploadedPdfs = [];
        let currentPdfFiles = []; // ä¿å­˜å½“å‰PDFæ–‡ä»¶æ•°ç»„
        let currentPage = 0; // å½“å‰æ˜¾ç¤ºé¡µ
        let totalPages = 1; // æ€»é¡µæ•°
        let debugMode = false; // è°ƒè¯•æ¨¡å¼å¼€å…³
        
        // æ€§èƒ½ç›‘æ§
        const performanceMonitor = {
            startTime: 0,
            memoryUsage: [],
            
            start(operation) {
                this.startTime = performance.now();
                if (debugMode) {
                    console.log(`ğŸš€ å¼€å§‹ ${operation}`);
                }
            },
            
            end(operation) {
                const duration = performance.now() - this.startTime;
                if (debugMode) {
                    console.log(`âœ… ${operation} å®Œæˆï¼Œè€—æ—¶: ${duration.toFixed(2)}ms`);
                }
                return duration;
            },
            
            checkMemory() {
                if (performance.memory) {
                    const memory = {
                        used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                        total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                        limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                    };
                    
                    if (debugMode) {
                        console.log(`ğŸ’¾ å†…å­˜ä½¿ç”¨: ${memory.used}MB / ${memory.total}MB (é™åˆ¶: ${memory.limit}MB)`);
                    }
                    
                    this.memoryUsage.push(memory);
                    return memory;
                }
                return null;
            },
            
            cleanup() {
                // å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                if (window.gc) {
                    window.gc();
                    if (debugMode) {
                        console.log('ğŸ—‘ï¸ æ‰§è¡Œåƒåœ¾å›æ”¶');
                    }
                }
            }
        };
        
        // å†…å­˜ç®¡ç†å·¥å…·
        const memoryManager = {
            maxCacheSize: 50 * 1024 * 1024, // 50MBç¼“å­˜é™åˆ¶
            
            clearImageCache() {
                // æ¸…ç†æœªä½¿ç”¨çš„å›¾ç‰‡ç¼“å­˜
                uploadedImages = uploadedImages.filter((img, index) => {
                    const keep = index < currentPage * MAX_IMAGES_PER_PAGE + MAX_IMAGES_PER_PAGE;
                    if (!keep && img.src) {
                        URL.revokeObjectURL(img.src);
                    }
                    return keep;
                });
                
                if (debugMode) {
                    console.log('ğŸ§¹ æ¸…ç†å›¾ç‰‡ç¼“å­˜');
                }
            },
            
            optimizeCanvas() {
                // ä¼˜åŒ–canvaså†…å­˜ä½¿ç”¨
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(canvas, 0, 0);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(tempCanvas, 0, 0);
                
                if (debugMode) {
                    console.log('ğŸ¨ ä¼˜åŒ–canvaså†…å­˜');
                }
            }
        };

        // è®¾ç½®PDF.js workerè·¯å¾„å’ŒCMapé…ç½®
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        // é…ç½®CMapä»¥æ”¯æŒä¸­æ–‡ç­‰éASCIIå­—ç¬¦ï¼ˆå¤šä¸ªå¤‡ç”¨CDNæºï¼‰
        const cMapUrls = [
            'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/cmaps/',
            'https://unpkg.com/pdfjs-dist@3.11.174/cmaps/',
            'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/cmaps/'
        ];
        
        // ä½¿ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨çš„CDNæº
        pdfjsLib.cMapUrl = cMapUrls[0];
        pdfjsLib.cMapPacked = true;

        // åˆå§‹åŒ–ç”»å¸ƒ
        function initCanvas() {
            // è®¾ç½®canvasçš„å®é™…åƒç´ å°ºå¯¸ï¼ˆ300 DPIï¼‰
            canvas.width = A4_WIDTH;
            canvas.height = A4_HEIGHT;
            
            // è®¾ç½®canvasçš„CSSæ˜¾ç¤ºå°ºå¯¸ï¼ˆç¼©æ”¾åˆ°é€‚åˆå±å¹•ï¼‰
            const displayScale = Math.min(window.innerWidth / A4_WIDTH * 0.8, 1);
            canvas.style.width = (A4_WIDTH * displayScale) + 'px';
            canvas.style.height = (A4_HEIGHT * displayScale) + 'px';
            
            // é‡ç½®å˜æ¢çŸ©é˜µ
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            // å¯ç”¨æœ€é«˜è´¨é‡æ¸²æŸ“
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.textRenderingOptimization = 'optimizeQuality';
            
            // è®¾ç½®é«˜è´¨é‡æ¸²æŸ“å‚æ•°
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, A4_WIDTH, A4_HEIGHT);
            
            // ç»˜åˆ¶å‘ç¥¨é—´éš”å’Œé»‘çº¿
            for (let i = 1; i < 3; i++) {
                const y = i * SECTION_HEIGHT;
                
                // ç»˜åˆ¶é—´éš”åŒºåŸŸï¼ˆç™½è‰²èƒŒæ™¯ï¼‰
                ctx.fillStyle = 'white';
                ctx.fillRect(0, y - INVOICE_SPACING/2, A4_WIDTH, INVOICE_SPACING);
                
                // ç»˜åˆ¶é»‘çº¿
                ctx.strokeStyle = 'black';
                ctx.lineWidth = INVOICE_LINE_HEIGHT;
                ctx.setLineDash([]); // å®çº¿
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(A4_WIDTH, y);
                ctx.stroke();
            }
        }

        // æ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯
        function showStatus(message, type = 'info') {
            status.textContent = message;
            status.className = `status ${type}`;
        }

        // æ›´æ–°å›¾ç‰‡ä¿¡æ¯æ˜¾ç¤º
        function updateImageInfo() {
            imageInfo.innerHTML = '';
            
            // æ˜¾ç¤ºå›¾ç‰‡ä¿¡æ¯
            uploadedImages.forEach((img, index) => {
                const item = document.createElement('div');
                item.className = 'image-item';
                
                const preview = document.createElement('img');
                preview.src = img.src;
                preview.alt = `å›¾ç‰‡ ${index + 1}`;
                
                const info = document.createElement('p');
                info.textContent = `å›¾ç‰‡ ${index + 1}: ${img.naturalWidth} Ã— ${img.naturalHeight}`;
                
                item.appendChild(preview);
                item.appendChild(info);
                imageInfo.appendChild(item);
            });

            // æ˜¾ç¤ºPDFä¿¡æ¯
            uploadedPdfs.forEach((pdfData, index) => {
                const item = document.createElement('div');
                item.className = 'image-item';
                
                const preview = document.createElement('img');
                preview.src = pdfData.preview;
                preview.alt = `PDF ${index + 1}`;
                
                const info = document.createElement('p');
                info.textContent = `PDF ${index + 1}: ${pdfData.width} Ã— ${pdfData.height}`;
                
                const fileName = document.createElement('p');
                fileName.textContent = pdfData.fileName || `æ–‡ä»¶ ${index + 1}`;
                fileName.style.fontSize = '10px';
                fileName.style.color = '#666';
                fileName.style.fontWeight = 'bold';
                
                const pageInfo = document.createElement('p');
                pageInfo.textContent = `é¡µé¢: ${pdfData.pageNumber}`;
                pageInfo.style.fontSize = '10px';
                pageInfo.style.color = '#999';
                
                // æ˜¾ç¤ºè£å‰ªä¿¡æ¯
                if (pdfData.originalSize && pdfData.croppedSize) {
                    const cropInfo = document.createElement('p');
                    cropInfo.textContent = `åŸå§‹: ${pdfData.originalSize}`;
                    cropInfo.style.fontSize = '9px';
                    cropInfo.style.color = '#999';
                    
                    const finalInfo = document.createElement('p');
                    finalInfo.textContent = `è£å‰ª: ${pdfData.croppedSize}`;
                    finalInfo.style.fontSize = '9px';
                    finalInfo.style.color = '#28a745';
                    finalInfo.style.fontWeight = 'bold';
                    
                    item.appendChild(cropInfo);
                    item.appendChild(finalInfo);
                }
                
                item.appendChild(preview);
                item.appendChild(info);
                item.appendChild(fileName);
                item.appendChild(pageInfo);
                imageInfo.appendChild(item);
            });
        }

        // --- NEW EVENT LISTENERS ---

        // 1. Main File Input (Clear and Load)
        mainFileInput.addEventListener('change', async function (e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) {
                mainFileInput.value = ''; // Reset input if no file is chosen
                return; // Do nothing if no files are selected
            }

            clearCanvas(); // Clear everything only after confirming file selection
            await handleFiles(files);
            mainFileInput.value = ''; // Reset input
        });

        // 2. Add Image Input (Append Only)
        imageInput.addEventListener('change', async function (e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            await handleFiles(files, false, true); // Process images only
            imageInput.value = ''; // Reset input
        });

        // 3. Add PDF Input (Append Only)
        pdfInput.addEventListener('change', async function (e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            await handleFiles(files, true, false); // Process PDFs only
            pdfInput.value = ''; // Reset input
        });

        // Universal file handler function
        async function handleFiles(files, processPdf = true, processImage = true) {
            // æ£€æŸ¥æ€»æ–‡ä»¶æ•°é‡é™åˆ¶
            const totalAfterUpload = uploadedImages.length + files.length;
            const maxTotalFiles = MAX_IMAGES_PER_PAGE * MAX_PAGES;
            if (totalAfterUpload > maxTotalFiles) {
                showStatus(`æœ€å¤šåªèƒ½å¤„ç†${maxTotalFiles}ä¸ªæ–‡ä»¶ï¼Œå½“å‰å·²æœ‰${uploadedImages.length}ä¸ª`, 'error');
                return;
            }

            // åˆ†ç¦»å›¾ç‰‡å’ŒPDFæ–‡ä»¶
            const imageFiles = processImage ? files.filter(file => file.type.startsWith('image/')) : [];
            const pdfFiles = processPdf ? files.filter(file => file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) : [];

            // å¤„ç†å›¾ç‰‡æ–‡ä»¶
            if (imageFiles.length > 0) {
                await processImageFiles(imageFiles);
            }

            // å¤„ç†PDFæ–‡ä»¶
            if (pdfFiles.length > 0) {
                currentPdfFiles.push(...pdfFiles); // Append to current PDF files for reprocessing
                await processMultiplePDFs(pdfFiles);
            }
        }

        // é‡æ–°å¤„ç†PDF (å¢å¼ºç‰ˆ)
        async function reprocessPDF() {
            // ä» uploadedPdfs ä¸­æ”¶é›†æ‰€æœ‰åŸå§‹PDFæ–‡ä»¶ï¼Œå¹¶å»é‡
            const uniquePdfFiles = [...new Set(uploadedPdfs.map(p => p.sourceFile).filter(Boolean))];

            if (uniquePdfFiles.length > 0) {
                // æ‰¾åˆ°ç¬¬ä¸€ä¸ªç”±PDFè½¬æ¢æ¥çš„å›¾ç‰‡åœ¨ uploadedImages ä¸­çš„ç´¢å¼•
                const firstPdfImageIndex = uploadedImages.findIndex((img, index) => uploadedPdfs[index] && uploadedPdfs[index].sourceFile);

                if (firstPdfImageIndex !== -1) {
                    // ä»è¯¥ç´¢å¼•å¼€å§‹ï¼Œç§»é™¤æ‰€æœ‰æ—§çš„PDFå›¾ç‰‡å’Œæ•°æ®
                    uploadedImages.splice(firstPdfImageIndex);
                    uploadedPdfs.splice(0); // æ¸…ç©ºPDFæ•°æ®æ•°ç»„
                    currentPdfFiles = []; // æ¸…ç©ºä¸´æ—¶æ•°ç»„

                    showStatus(`æ­£åœ¨ä½¿ç”¨æ–°è®¾ç½®é‡æ–°å¤„ç† ${uniquePdfFiles.length} ä¸ªPDF...`, 'info');
                    // ä½¿ç”¨æ”¶é›†åˆ°çš„æ‰€æœ‰å”¯ä¸€PDFæ–‡ä»¶è¿›è¡Œé‡æ–°å¤„ç†
                    await processMultiplePDFs(uniquePdfFiles);
                } else {
                    showStatus('æœªæ‰¾åˆ°å¯é‡æ–°å¤„ç†çš„PDFå›¾ç‰‡ã€‚', 'warning');
                }
            } else {
                showStatus('æ²¡æœ‰å·²åŠ è½½çš„PDFæ–‡ä»¶å¯ä¾›é‡æ–°å¤„ç†ã€‚', 'info');
            }
        }

        // æ£€æµ‹å›¾ç‰‡ä¸­çš„ç©ºç™½åŒºåŸŸ
        function detectContentBounds(canvas, threshold = 0.95) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
            let hasContent = false;
            let totalBrightness = 0;
            let pixelCount = 0;
            
            // é¦–å…ˆè®¡ç®—æ•´ä½“äº®åº¦åˆ†å¸ƒ
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 4;
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];
                    const brightness = (r + g + b) / 3;
                    totalBrightness += brightness;
                    pixelCount++;
                }
            }
            
            const avgBrightness = totalBrightness / pixelCount;
            if (debugMode) {
                console.log('=== å†…å®¹æ£€æµ‹è°ƒè¯•ä¿¡æ¯ ===');
                console.log('ç”»å¸ƒå°ºå¯¸:', canvas.width, 'x', canvas.height);
                console.log('æ€»åƒç´ æ•°:', pixelCount);
                console.log('å¹³å‡äº®åº¦:', avgBrightness.toFixed(2));
            }
            
            // æ ¹æ®å¹³å‡äº®åº¦åŠ¨æ€è°ƒæ•´ç™½è‰²é˜ˆå€¼
            const whiteThreshold = Math.max(240, avgBrightness + 30);
            if (debugMode) {
                console.log('ç™½è‰²é˜ˆå€¼:', whiteThreshold);
            }
            
            // é‡æ–°éå†åƒç´ æ•°æ®ï¼Œå¯»æ‰¾éç™½è‰²åƒç´ 
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 4;
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];
                    const a = data[index + 3];
                    
                    // è·³è¿‡å®Œå…¨é€æ˜çš„åƒç´ 
                    if (a === 0) continue;
                    
                    const brightness = (r + g + b) / 3;
                    
                    // æ›´æ™ºèƒ½çš„å†…å®¹æ£€æµ‹ï¼š
                    // 1. äº®åº¦ä½äºé˜ˆå€¼
                    // 2. æˆ–è€…RGBå€¼å·®å¼‚è¾ƒå¤§ï¼ˆå½©è‰²å†…å®¹ï¼‰
                    // 3. æˆ–è€…æœ‰æ˜æ˜¾çš„å¯¹æ¯”åº¦å˜åŒ–
                    const hasLowBrightness = brightness < whiteThreshold;
                    const hasColorVariation = Math.abs(r - g) > 15 || Math.abs(g - b) > 15 || Math.abs(r - b) > 15;
                    const isDarkContent = (r < 200 && g < 200 && b < 200);
                    
                    if (hasLowBrightness || hasColorVariation || isDarkContent) {
                        hasContent = true;
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            if (!hasContent) {
                if (debugMode) {
                    console.log('æœªæ£€æµ‹åˆ°å†…å®¹ï¼Œè¿”å›å®Œæ•´ç”»å¸ƒ');
                }
                return null; // æ²¡æœ‰æ£€æµ‹åˆ°å†…å®¹ï¼Œè¿”å›nullè¡¨ç¤ºä¸è£å‰ª
            }
            
            // æ·»åŠ ä¸€äº›è¾¹è·
            const margin = 15;
            const bounds = {
                x: Math.max(0, minX - margin),
                y: Math.max(0, minY - margin),
                width: Math.min(canvas.width - minX, maxX - minX + 2 * margin),
                height: Math.min(canvas.height - minY, maxY - minY + 2 * margin)
            };
            
            if (debugMode) {
                console.log('æ£€æµ‹åˆ°çš„å†…å®¹è¾¹ç•Œ:', bounds);
                console.log('å†…å®¹åŒºåŸŸå æ¯”:', ((bounds.width * bounds.height) / (canvas.width * canvas.height) * 100).toFixed(2) + '%');
            }
            return bounds;
        }

        // å¤‡ç”¨å†…å®¹æ£€æµ‹æ–¹æ³•ï¼ˆæ›´å®½æ¾çš„æ£€æµ‹æ¡ä»¶ï¼‰
        function detectContentBoundsRelaxed(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
            let hasContent = false;
            
            // ä½¿ç”¨éå¸¸å®½æ¾çš„æ£€æµ‹æ¡ä»¶
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 4;
                    const r = data[index];
                    const g = data[index + 1];
                    const b = data[index + 2];
                    const a = data[index + 3];
                    
                    // è·³è¿‡å®Œå…¨é€æ˜çš„åƒç´ 
                    if (a === 0) continue;
                    
                    // éå¸¸å®½æ¾çš„æ¡ä»¶ï¼šåªè¦ä¸æ˜¯æ¥è¿‘çº¯ç™½è‰²å°±è®¤ä¸ºæ˜¯å†…å®¹
                    const isNearWhite = (r > 245 && g > 245 && b > 245);
                    
                    if (!isNearWhite) {
                        hasContent = true;
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            if (!hasContent) {
                console.log('å¤‡ç”¨æ£€æµ‹ï¼šæœªæ£€æµ‹åˆ°å†…å®¹');
                return null;
            }
            
            // æ·»åŠ è¾ƒå¤§çš„è¾¹è·
            const margin = 25;
            const bounds = {
                x: Math.max(0, minX - margin),
                y: Math.max(0, minY - margin),
                width: Math.min(canvas.width - minX, maxX - minX + 2 * margin),
                height: Math.min(canvas.height - minY, maxY - minY + 2 * margin)
            };
            
            console.log('å¤‡ç”¨æ£€æµ‹åˆ°çš„å†…å®¹è¾¹ç•Œ:', bounds);
            return bounds;
        }

        // è£å‰ªå›¾ç‰‡åˆ°å†…å®¹åŒºåŸŸ
        function cropToContent(canvas, bounds) {
            if (!bounds) return canvas;
            
            const croppedCanvas = document.createElement('canvas');
            const croppedCtx = croppedCanvas.getContext('2d');
            
            croppedCanvas.width = bounds.width;
            croppedCanvas.height = bounds.height;
            
            // ç»˜åˆ¶è£å‰ªåçš„å†…å®¹
            croppedCtx.drawImage(
                canvas,
                bounds.x, bounds.y, bounds.width, bounds.height,
                0, 0, bounds.width, bounds.height
            );
            
            return croppedCanvas;
        }

        // PDFå¤„ç†ç¼“å­˜
        const pdfCache = new Map();
        
        // å¤„ç†å¤šä¸ªPDFæ–‡ä»¶ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
        async function processMultiplePDFs(files) {
            performanceMonitor.start('PDFæ‰¹é‡å¤„ç†');
            performanceMonitor.checkMemory();
            
            try {
                progressBar.show();
                progressBar.update(0, `å‡†å¤‡å¤„ç† ${files.length} ä¸ªPDFæ–‡ä»¶...`);
                
                // æ£€æŸ¥å‰©ä½™æ§½ä½
                const remainingSlots = MAX_IMAGES_PER_PAGE * MAX_PAGES - uploadedImages.length;
                if (remainingSlots <= 0) {
                    showStatus(`å·²è¾¾åˆ°æœ€å¤š${MAX_IMAGES_PER_PAGE * MAX_PAGES}ä¸ªæ–‡ä»¶çš„é™åˆ¶ã€‚å¦‚éœ€ç»§ç»­ï¼Œè¯·å…ˆæ¸…ç©ºç”»å¸ƒã€‚`, 'error');
                    return;
                }

                // åªå¤„ç†èƒ½å®¹çº³çš„æ–‡ä»¶æ•°é‡
                const filesToProcess = files.slice(0, Math.max(0, remainingSlots));
                if (filesToProcess.length < files.length) {
                    showStatus(`æœ¬æ¬¡æœ€å¤šè¿˜èƒ½æ·»åŠ  ${remainingSlots} ä¸ªæ–‡ä»¶ï¼ˆæ€»è®¡ä¸è¶…è¿‡${MAX_IMAGES_PER_PAGE * MAX_PAGES}ä¸ªï¼‰`, 'info');
                }
                
                const renderScale = getPdfRenderScale();
                const startIndex = uploadedImages.length; // è®°å½•æ–°å¢æ–‡ä»¶çš„èµ·å§‹ä½ç½®
                
                // å¹¶å‘å¤„ç†PDFæ–‡ä»¶ï¼ˆé™åˆ¶å¹¶å‘æ•°ä¸º3ï¼‰
                const concurrencyLimit = 3;
                const chunks = [];
                for (let i = 0; i < filesToProcess.length; i += concurrencyLimit) {
                    chunks.push(filesToProcess.slice(i, i + concurrencyLimit));
                }
                
                let processedCount = 0;
                const progressIncrement = 100 / filesToProcess.length;
                
                for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
                    const chunk = chunks[chunkIndex];
                    
                    // å¹¶å‘å¤„ç†å½“å‰æ‰¹æ¬¡
                    const promises = chunk.map(async (file, index) => {
                        const globalIndex = startIndex + filesToProcess.indexOf(file);
                        return await processSinglePDF(file, globalIndex, renderScale, chunkIndex);
                    });
                    
                    // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
                    const results = await Promise.allSettled(promises);
                    
                    // å¤„ç†ç»“æœ
                    for (const result of results) {
                        if (result.status === 'fulfilled') {
                            processedCount++;
                            progressBar.increment(progressIncrement, `å·²å¤„ç† ${processedCount}/${filesToProcess.length} ä¸ªPDFæ–‡ä»¶...`);
                        } else {
                            console.error('PDFå¤„ç†å¤±è´¥:', result.reason);
                            debouncedShowStatus(`PDFå¤„ç†å¤±è´¥: ${result.reason.message}`, 'error');
                        }
                    }
                    
                    // æ‰¹æ¬¡é—´çŸ­æš‚ä¼‘æ¯ï¼Œé¿å…é˜»å¡UI
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                
                // å®Œæˆå¤„ç†
                if (processedCount === filesToProcess.length) {
                    progressBar.update(100, 'å¤„ç†å®Œæˆï¼Œæ­£åœ¨æ›´æ–°ç•Œé¢...');
                    
                    // æ›´æ–°æ€»é¡µæ•°
                    totalPages = Math.ceil(uploadedImages.length / MAX_IMAGES_PER_PAGE);

                    // æ˜¾ç¤ºæˆ–éšè—åˆ†é¡µæ§ä»¶
                    const paginationControls = document.getElementById('paginationControls');
                    if (totalPages > 1) {
                        paginationControls.style.display = 'block';
                        updatePaginationButtons();
                        updatePageInfo();
                    }

                    drawCurrentPage();
                    updateImageInfo();
                    exportBtn.disabled = false;
                    previewBtn.disabled = false;
                    document.getElementById('reprocessBtn').style.display = 'inline-flex';
                    
                    performanceMonitor.end('PDFæ‰¹é‡å¤„ç†');
                    performanceMonitor.checkMemory();
                    performanceMonitor.cleanup();
                    
                    progressBar.hide();
                    showStatus(`æˆåŠŸå¤„ç† ${filesToProcess.length} ä¸ªPDFæ–‡ä»¶ï¼Œæ¸²æŸ“è´¨é‡: ${renderScale}xï¼Œå…± ${totalPages} é¡µ`, 'success');
                } else {
                    progressBar.hide();
                    showStatus(`éƒ¨åˆ†å¤„ç†å®Œæˆï¼š${processedCount}/${filesToProcess.length} ä¸ªPDFæ–‡ä»¶`, 'warning');
                }
                
            } catch (error) {
                progressBar.hide();
                showStatus('PDFå¤„ç†å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼æˆ–å°è¯•å…³é—­è‡ªåŠ¨è£å‰ª', 'error');
                console.error('PDF processing error:', error);
                
                // å¦‚æœæ˜¯CMapé”™è¯¯ï¼Œæä¾›å…·ä½“çš„è§£å†³å»ºè®®
                if (error.message && error.message.includes('CMap')) {
                    showStatus('PDFå­—ä½“åŠ è½½å¤±è´¥ï¼Œå»ºè®®ï¼š1) å¼€å¯è°ƒè¯•æ¨¡å¼æŸ¥çœ‹è¯¦æƒ… 2) å°è¯•å…³é—­è‡ªåŠ¨è£å‰ª', 'warning');
                }
            }
        }
        
        // å¤„ç†å•ä¸ªPDFæ–‡ä»¶
        async function processSinglePDF(file, targetIndex, renderScale, chunkIndex) {
            performanceMonitor.start(`PDFå¤„ç† ${targetIndex + 1}`);
            
            try {
                console.log(`å¤„ç†PDF ${targetIndex + 1}: ${file.name}`);
                
                // æ£€æŸ¥ç¼“å­˜
                const cacheKey = `${file.name}_${file.size}_${renderScale}`;
                if (pdfCache.has(cacheKey)) {
                    if (debugMode) {
                        console.log(`ğŸ“¦ ä½¿ç”¨ç¼“å­˜: ${file.name}`);
                    }
                    return pdfCache.get(cacheKey);
                }
                
                const arrayBuffer = await file.arrayBuffer();
                
                // å°è¯•å¤šä¸ªCDNæºåŠ è½½PDF
                let pdf = null;
                
                for (let cMapIndex = 0; cMapIndex < cMapUrls.length; cMapIndex++) {
                    const cMapUrl = cMapUrls[cMapIndex];
                    const standardFontUrl = cMapUrl.replace('/cmaps/', '/standard_fonts/');
                    
                    try {
                        if (debugMode) {
                            console.log(`PDF ${targetIndex + 1} å°è¯•ä½¿ç”¨CDNæº ${cMapIndex + 1}: ${cMapUrl}`);
                        }
                        
                        const loadingTask = pdfjsLib.getDocument({
                            data: arrayBuffer,
                            cMapUrl: cMapUrl,
                            cMapPacked: true,
                            standardFontDataUrl: standardFontUrl,
                            disableFontFace: false,
                            disableAutoFetch: false,
                            disableStream: false
                        });
                        
                        pdf = await loadingTask.promise;
                        if (debugMode) {
                            console.log(`PDF ${targetIndex + 1} CDN ${cMapIndex + 1} åŠ è½½æˆåŠŸ`);
                        }
                        break;
                        
                    } catch (error) {
                        console.warn(`PDF ${targetIndex + 1} CDN ${cMapIndex + 1} åŠ è½½å¤±è´¥:`, error.message);
                    }
                }
                
                // å¤‡ç”¨æ–¹æ¡ˆ
                if (!pdf) {
                    const fallbackTask = pdfjsLib.getDocument({
                        data: arrayBuffer,
                        disableFontFace: true,
                        disableAutoFetch: true,
                        disableStream: true
                    });
                    
                    pdf = await fallbackTask.promise;
                }
                
                // æ¸²æŸ“é¡µé¢
                const page = await pdf.getPage(1);
                const viewport = page.getViewport({ scale: renderScale });
                
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = viewport.width;
                tempCanvas.height = viewport.height;
                
                tempCtx.imageSmoothingEnabled = true;
                tempCtx.imageSmoothingQuality = 'high';
                tempCtx.textRenderingOptimization = 'optimizeQuality';
                tempCtx.fillStyle = 'white';
                tempCtx.fillRect(0, 0, viewport.width, viewport.height);
                
                await page.render({
                    canvasContext: tempCtx,
                    viewport: viewport,
                    background: 'white',
                    intent: 'print' // ä½¿ç”¨æ‰“å°è´¨é‡æ¸²æŸ“
                }).promise;
                
                // å†…å®¹æ£€æµ‹
                let contentBounds = null;
                if (isAutoCropEnabled()) {
                    contentBounds = detectContentBounds(tempCanvas);
                    if (!contentBounds) {
                        contentBounds = detectContentBoundsRelaxed(tempCanvas);
                    }
                }
                
                // è£å‰ª
                let finalCanvas = tempCanvas;
                if (contentBounds && isAutoCropEnabled()) {
                    finalCanvas = cropToContent(tempCanvas, contentBounds);
                    if (finalCanvas.width < 100 || finalCanvas.height < 100) {
                        finalCanvas = tempCanvas;
                    }
                }
                
                // è½¬æ¢ä¸ºå›¾ç‰‡
                const result = await new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        uploadedImages[targetIndex] = img;
                        uploadedPdfs[targetIndex] = {
                            preview: finalCanvas.toDataURL('image/png', 1.0),
                            width: finalCanvas.width,
                            height: finalCanvas.height,
                            pageNumber: 1,
                            fileName: file.name,
                            originalSize: `${viewport.width} Ã— ${viewport.height}`,
                            croppedSize: contentBounds ? `${finalCanvas.width} Ã— ${finalCanvas.height}` : 'æœªè£å‰ª'
                        };
                        resolve(img);
                    };
                    img.src = finalCanvas.toDataURL('image/png', 1.0);
                });
                
                // ç¼“å­˜ç»“æœ
                pdfCache.set(cacheKey, result);
                
                performanceMonitor.end(`PDFå¤„ç† ${targetIndex + 1}`);
                return result;
                
            } catch (error) {
                performanceMonitor.end(`PDFå¤„ç† ${targetIndex + 1} (å¤±è´¥)`);
                throw error;
            }
        }

        // ç»˜åˆ¶å½“å‰é¡µå†…å®¹
        function drawCurrentPage() {
            initCanvas();
            
            // å¯ç”¨æœ€é«˜è´¨é‡å›¾åƒæ¸²æŸ“
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.textRenderingOptimization = 'optimizeQuality';
            
            // è®¡ç®—å½“å‰é¡µçš„å›¾ç‰‡èŒƒå›´
            const startIndex = currentPage * MAX_IMAGES_PER_PAGE;
            const endIndex = Math.min(startIndex + MAX_IMAGES_PER_PAGE, uploadedImages.length);

            for (let i = startIndex; i < endIndex; i++) {
                const img = uploadedImages[i];
                if (!img) continue;

                const pagePosition = i % MAX_IMAGES_PER_PAGE;
                
                // è®¡ç®—å®é™…å¯ç”¨é«˜åº¦ï¼ˆè€ƒè™‘é—´éš”ï¼‰
                const availableHeight = SECTION_HEIGHT - INVOICE_SPACING;
                const y = pagePosition * SECTION_HEIGHT + INVOICE_SPACING / 2;
                
                // è®¡ç®—å›¾ç‰‡å°ºå¯¸ï¼Œä¿æŒå®½é«˜æ¯”
                const imgAspectRatio = img.naturalWidth / img.naturalHeight;
                const sectionAspectRatio = A4_WIDTH / availableHeight;
                
                let drawWidth, drawHeight, drawX, drawY;
                
                if (imgAspectRatio > sectionAspectRatio) {
                    // å›¾ç‰‡æ›´å®½ï¼Œä»¥å®½åº¦ä¸ºå‡†
                    drawWidth = A4_WIDTH;
                    drawHeight = A4_WIDTH / imgAspectRatio;
                    drawX = 0;
                    drawY = y + (availableHeight - drawHeight) / 2;
                } else {
                    // å›¾ç‰‡æ›´é«˜ï¼Œä»¥é«˜åº¦ä¸ºå‡†
                    drawHeight = availableHeight;
                    drawWidth = availableHeight * imgAspectRatio;
                    drawX = (A4_WIDTH - drawWidth) / 2;
                    drawY = y;
                }
                
                // ç»˜åˆ¶å›¾ç‰‡ï¼ˆä½¿ç”¨é«˜è´¨é‡æ¸²æŸ“ï¼‰
                ctx.save();
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                ctx.restore();
                
                // ç»˜åˆ¶è¾¹æ¡†
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 2;
                ctx.strokeRect(drawX, drawY, drawWidth, drawHeight);

                // æ·»åŠ é¡µç æ ‡è®°ï¼ˆå³ä¸‹è§’ï¼‰
                if (pagePosition === MAX_IMAGES_PER_PAGE - 1 || i === uploadedImages.length - 1) {
                    ctx.save();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.font = 'bold 48px Arial'; // æ”¾å¤§å­—ä½“ä»¥åŒ¹é…300 DPI
                    ctx.textAlign = 'right';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(`ç¬¬ ${currentPage + 1} é¡µ`, A4_WIDTH - 40, A4_HEIGHT - 40);
                    ctx.restore();
                }
            }
        }



        // å¯¼å‡ºå›¾ç‰‡ï¼ˆæ”¯æŒå¤šé¡µï¼‰
        function exportImage() {
            try {
                if (totalPages === 1) {
                    // å•é¡µå¯¼å‡º
                    exportSinglePage();
                } else {
                    // å¤šé¡µå¯¼å‡ºä¸ºZIP
                    exportMultiplePages();
                }
            } catch (error) {
                showStatus('å¯¼å‡ºå¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
                console.error('Export error:', error);
            }
        }

        // å¯¼å‡ºå•é¡µ
        function exportSinglePage() {
                const exportScale = 1; // ç›´æ¥ä½¿ç”¨300 DPIï¼Œæ— éœ€é¢å¤–ç¼©æ”¾
                const exportCanvas = document.createElement('canvas');
                const exportCtx = exportCanvas.getContext('2d');
                
                exportCanvas.width = A4_WIDTH;
                exportCanvas.height = A4_HEIGHT;
                
                // å¯ç”¨æœ€é«˜è´¨é‡æ¸²æŸ“
                exportCtx.imageSmoothingEnabled = true;
                exportCtx.imageSmoothingQuality = 'high';
                exportCtx.textRenderingOptimization = 'optimizeQuality';
                
                // ç»˜åˆ¶ç™½è‰²èƒŒæ™¯
                exportCtx.fillStyle = 'white';
                exportCtx.fillRect(0, 0, A4_WIDTH, A4_HEIGHT);
                
                // ç»˜åˆ¶å‘ç¥¨é—´éš”å’Œé»‘çº¿
                for (let i = 1; i < 3; i++) {
                    const y = i * SECTION_HEIGHT;
                    
                    // ç»˜åˆ¶é—´éš”åŒºåŸŸï¼ˆç™½è‰²èƒŒæ™¯ï¼‰
                    exportCtx.fillStyle = 'white';
                    exportCtx.fillRect(0, y - INVOICE_SPACING/2, A4_WIDTH, INVOICE_SPACING);
                    
                    // ç»˜åˆ¶é»‘çº¿
                    exportCtx.strokeStyle = 'black';
                    exportCtx.lineWidth = INVOICE_LINE_HEIGHT;
                    exportCtx.setLineDash([]); // å®çº¿
                    exportCtx.beginPath();
                    exportCtx.moveTo(0, y);
                    exportCtx.lineTo(A4_WIDTH, y);
                    exportCtx.stroke();
                }
                
            // é‡æ–°ç»˜åˆ¶å½“å‰é¡µæ‰€æœ‰å›¾ç‰‡åˆ°é«˜åˆ†è¾¨ç‡canvas
            const startIndex = currentPage * MAX_IMAGES_PER_PAGE;
            const endIndex = Math.min(startIndex + MAX_IMAGES_PER_PAGE, uploadedImages.length);

            for (let i = startIndex; i < endIndex; i++) {
                const img = uploadedImages[i];
                if (!img) continue;

                const pagePosition = i % MAX_IMAGES_PER_PAGE;
                
                // è®¡ç®—å®é™…å¯ç”¨é«˜åº¦ï¼ˆè€ƒè™‘é—´éš”ï¼‰
                const availableHeight = SECTION_HEIGHT - INVOICE_SPACING;
                const y = pagePosition * SECTION_HEIGHT + INVOICE_SPACING / 2;
                    
                    // è®¡ç®—å›¾ç‰‡å°ºå¯¸ï¼Œä¿æŒå®½é«˜æ¯”
                    const imgAspectRatio = img.naturalWidth / img.naturalHeight;
                    const sectionAspectRatio = A4_WIDTH / availableHeight;
                    
                    let drawWidth, drawHeight, drawX, drawY;
                    
                    if (imgAspectRatio > sectionAspectRatio) {
                        drawWidth = A4_WIDTH;
                        drawHeight = A4_WIDTH / imgAspectRatio;
                        drawX = 0;
                        drawY = y + (availableHeight - drawHeight) / 2;
                    } else {
                        drawHeight = availableHeight;
                        drawWidth = availableHeight * imgAspectRatio;
                        drawX = (A4_WIDTH - drawWidth) / 2;
                        drawY = y;
                    }
                    
                    // ç»˜åˆ¶å›¾ç‰‡ï¼ˆæœ€é«˜è´¨é‡ï¼‰
                    exportCtx.save();
                    exportCtx.imageSmoothingEnabled = true;
                    exportCtx.imageSmoothingQuality = 'high';
                    exportCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                    exportCtx.restore();
                    
                    // ç»˜åˆ¶è¾¹æ¡†
                    exportCtx.strokeStyle = '#999';
                    exportCtx.lineWidth = 2;
                    exportCtx.strokeRect(drawX, drawY, drawWidth, drawHeight);
            }
                
                const link = document.createElement('a');
            link.download = `å¯¼å‡ºé¡µé¢_${currentPage + 1}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
            link.href = exportCanvas.toDataURL('image/png', 1.0); // æœ€é«˜è´¨é‡PNG
                link.click();
            showStatus('å•é¡µå¯¼å‡ºæˆåŠŸï¼', 'success');
        }

        // å¯¼å‡ºå¤šé¡µï¼ˆæç¤ºç”¨æˆ·ï¼‰
        function exportMultiplePages() {
            if (confirm(`æ£€æµ‹åˆ° ${totalPages} é¡µå†…å®¹ã€‚æ˜¯å¦è¦é€é¡µå¯¼å‡ºæ‰€æœ‰é¡µé¢ï¼Ÿ\n\nç‚¹å‡»"ç¡®å®š"å¼€å§‹é€é¡µå¯¼å‡ºï¼Œç‚¹å‡»"å–æ¶ˆ"åªå¯¼å‡ºå½“å‰é¡µã€‚`)) {
                // é€é¡µå¯¼å‡ºæ‰€æœ‰é¡µé¢
                for (let page = 0; page < totalPages; page++) {
                    setTimeout(() => {
                        currentPage = page;
                        drawCurrentPage();

                        // ä¸ºæ¯é¡µåˆ›å»ºå•ç‹¬çš„å¯¼å‡º
                        const exportScale = 1; // ç›´æ¥ä½¿ç”¨300 DPI
                        const exportCanvas = document.createElement('canvas');
                        const exportCtx = exportCanvas.getContext('2d');

                        exportCanvas.width = A4_WIDTH;
                        exportCanvas.height = A4_HEIGHT;

                        exportCtx.imageSmoothingEnabled = true;
                        exportCtx.imageSmoothingQuality = 'high';
                        exportCtx.textRenderingOptimization = 'optimizeQuality';
                        exportCtx.fillStyle = 'white';
                        exportCtx.fillRect(0, 0, A4_WIDTH, A4_HEIGHT);

                        // ç»˜åˆ¶å‘ç¥¨é—´éš”å’Œé»‘çº¿
                        for (let i = 1; i < 3; i++) {
                            const y = i * SECTION_HEIGHT;
                            
                            // ç»˜åˆ¶é—´éš”åŒºåŸŸï¼ˆç™½è‰²èƒŒæ™¯ï¼‰
                            exportCtx.fillStyle = 'white';
                            exportCtx.fillRect(0, y - INVOICE_SPACING/2, A4_WIDTH, INVOICE_SPACING);
                            
                            // ç»˜åˆ¶é»‘çº¿
                            exportCtx.strokeStyle = 'black';
                            exportCtx.lineWidth = INVOICE_LINE_HEIGHT;
                            exportCtx.setLineDash([]); // å®çº¿
                            exportCtx.beginPath();
                            exportCtx.moveTo(0, y);
                            exportCtx.lineTo(A4_WIDTH, y);
                            exportCtx.stroke();
                        }
                        
                        // ç»˜åˆ¶å½“å‰é¡µå†…å®¹
                        const startIndex = page * MAX_IMAGES_PER_PAGE;
                        const endIndex = Math.min(startIndex + MAX_IMAGES_PER_PAGE, uploadedImages.length);

                        for (let i = startIndex; i < endIndex; i++) {
                            const img = uploadedImages[i];
                            if (!img) continue;

                            const pagePosition = i % MAX_IMAGES_PER_PAGE;
                            
                            // è®¡ç®—å®é™…å¯ç”¨é«˜åº¦ï¼ˆè€ƒè™‘é—´éš”ï¼‰
                            const availableHeight = SECTION_HEIGHT - INVOICE_SPACING;
                            const y = pagePosition * SECTION_HEIGHT + INVOICE_SPACING / 2;

                            const imgAspectRatio = img.naturalWidth / img.naturalHeight;
                            const sectionAspectRatio = A4_WIDTH / availableHeight;

                            let drawWidth, drawHeight, drawX, drawY;

                            if (imgAspectRatio > sectionAspectRatio) {
                                drawWidth = A4_WIDTH;
                                drawHeight = A4_WIDTH / imgAspectRatio;
                                drawX = 0;
                                drawY = y + (availableHeight - drawHeight) / 2;
                            } else {
                                drawHeight = availableHeight;
                                drawWidth = availableHeight * imgAspectRatio;
                                drawX = (A4_WIDTH - drawWidth) / 2;
                                drawY = y;
                            }

                            // ç»˜åˆ¶å›¾ç‰‡ï¼ˆæœ€é«˜è´¨é‡ï¼‰
                            exportCtx.save();
                            exportCtx.imageSmoothingEnabled = true;
                            exportCtx.imageSmoothingQuality = 'high';
                            exportCtx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                            exportCtx.restore();
                            
                            exportCtx.strokeStyle = '#999';
                            exportCtx.lineWidth = 2;
                            exportCtx.strokeRect(drawX, drawY, drawWidth, drawHeight);
                        }

                        const link = document.createElement('a');
                        link.download = `å¯¼å‡ºé¡µé¢_${page + 1}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
                        link.href = exportCanvas.toDataURL('image/png', 1.0); // æœ€é«˜è´¨é‡PNG
                        link.click();

                        if (page === totalPages - 1) {
                            showStatus(`æ‰€æœ‰ ${totalPages} é¡µå·²å¯¼å‡ºå®Œæˆï¼`, 'success');
                            // æ¢å¤å½“å‰æ˜¾ç¤ºé¡µ
                            currentPage = 0;
                            drawCurrentPage();
                            updatePaginationButtons();
                            updatePageInfo();
                        }
                    }, page * 500); // å»¶è¿Ÿå¯¼å‡ºï¼Œé¿å…æµè§ˆå™¨é˜»å¡
                }
            } else {
                // åªå¯¼å‡ºå½“å‰é¡µ
                exportSinglePage();
            }
        }

        // æ‰“å°å›¾ç‰‡ï¼ˆæ”¯æŒå¤šé¡µï¼‰
        function printImage() {
            try {
                if (totalPages === 1) {
                    // å•é¡µç›´æ¥æ‰“å°
                window.print();
                showStatus('æ­£åœ¨æ‰“å¼€æ‰“å°å¯¹è¯æ¡†...', 'success');
                } else {
                    // å¤šé¡µæ‰“å°é¢„è§ˆ
                    previewPrint();
                }
            } catch (error) {
                showStatus('æ‰“å°å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
                console.error('Print error:', error);
            }
        }

        // æ‰“å°é¢„è§ˆï¼ˆæ”¯æŒå¤šé¡µï¼‰
        function previewPrint() {
            try {
                const w = window.open('', '_blank', 'width=900,height=700');

                // åˆ›å»ºå¤šé¡µé¢„è§ˆå†…å®¹
                let previewContent = '';
                let actualPages = 0; // è®°å½•å®é™…æœ‰å†…å®¹çš„é¡µæ•°

                // ä¿å­˜å½“å‰é¡µ
                const originalPage = currentPage;

                // ä¸ºæ¯é¡µåˆ›å»ºé¢„è§ˆ
                for (let page = 0; page < totalPages; page++) {
                    currentPage = page;

                    // æ£€æŸ¥å½“å‰é¡µæ˜¯å¦æœ‰å›¾ç‰‡
                    const startIndex = currentPage * MAX_IMAGES_PER_PAGE;
                    const endIndex = Math.min(startIndex + MAX_IMAGES_PER_PAGE, uploadedImages.length);

                    // ç¡®ä¿å½“å‰é¡µæœ‰å›¾ç‰‡å†…å®¹æ‰ç”Ÿæˆé¢„è§ˆ
                    if (startIndex < uploadedImages.length && endIndex > startIndex) {
                        drawCurrentPage();
                        const pageImage = canvas.toDataURL('image/png', 1.0);
                        actualPages++;

                        previewContent += `
                            <div class="preview-page" style="margin-bottom: 30px; text-align: center;">
                                <div style="font-weight: bold; margin-bottom: 10px; color: #333;">ç¬¬ ${actualPages} é¡µ</div>
                                <img src="${pageImage}" class="preview-image" alt="ç¬¬ ${actualPages} é¡µ" style="max-width: 100%; height: auto; border: 1px solid #ddd; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            </div>
                        `;
                    }
                }

                // æ¢å¤å½“å‰é¡µ
                currentPage = originalPage;
                drawCurrentPage();

                const s = `
                    /* --- STYLES FOR PREVIEW WINDOW --- */
                    body {
                        margin: 0;
                        padding: 20px;
                        background-color: #f0f0f0;
                        font-family: sans-serif;
                    }
                    .preview-container, .preview-header, .preview-controls {
                        background-color: white;
                        text-align: center;
                        margin: 0 auto 20px auto;
                        padding: 15px;
                        border-radius: 8px;
                        max-width: 800px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                    }
                    .preview-page {
                        margin-bottom: 20px;
                        page-break-after: always; /* æ¯é¡µååˆ†é¡µ */
                    }
                    .preview-page:last-child {
                        margin-bottom: 0;
                        page-break-after: avoid; /* æœ€åä¸€é¡µä¸åˆ†é¡µ */
                    }
                    .preview-image {
                        max-width: 100%;
                        border: 1px solid #ccc;
                    }
                    .preview-btn {
                        padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; margin: 5px;
                        page-break-inside: avoid;
                    }
                    .print-btn { background-color: #28a745; color: white; }
                    .close-btn { background-color: #6c757d; color: white; }

                    /* --- STYLES FOR PRINTING --- */
                    @media print {
                        @page { 
                            size: A4; 
                            margin: 0; 
                          
                        }
                        body {
                            padding: 0;
                            margin: 0;
                            background-color: white;
                        }
                        /* Hide all UI elements except the images container */
                        .preview-header, .preview-controls {
                            display: none;
                        }
                        .preview-container {
                            margin: 0;
                            padding: 0;
                            box-shadow: none;
                            border-radius: 0;
                        }
                        .preview-page {
                            margin: 0;
                            padding: 0;
                            width: 100%;
                            height: 100%;
                        }
                        .preview-image {
                            width: 100%;
                            height: 100%;
                            border: none;
                            box-shadow: none;
                            object-fit: contain; /* Ensure image fits without distortion */
                        }
                    }
                `;

                const b = `
                    <div class="preview-header">
                        <h2>æ‰“å°é¢„è§ˆ - å…± ${actualPages} é¡µ</h2>
                        <p>è¯·æ£€æŸ¥ä»¥ä¸‹é¡µé¢ã€‚ç‚¹å‡»â€œæ‰“å°æ‰€æœ‰é¡µâ€å°†è°ƒç”¨ç³»ç»Ÿæ‰“å°åŠŸèƒ½ã€‚</p>
                    </div>
                    <div class="preview-container">
                        ${previewContent}
                    </div>
                    <div class="preview-controls">
                        <button class="preview-btn print-btn" onclick="printAllPages()">ğŸ–¨ï¸ æ‰“å°æ‰€æœ‰é¡µ</button>
                        <button class="preview-btn close-btn" onclick="window.close()">å…³é—­</button>
                    </div>
                `;

                const script = 'function printAllPages() {' +
                    'const images = document.querySelectorAll(".preview-image");' +
                    'if (images.length === 0) return;' +
                    'let printHtml = "";' +
                    'images.forEach((img, index) => {' +
                    'const isLast = index === images.length - 1;' +
                    'const pageBreak = isLast ? "" : "page-break-after: always;";' +
                    'printHtml += `<div style="width: 100%; height: 100vh; ${pageBreak}"><img src="${img.src}" style="width: 100%; height: 100vh; object-fit: contain;" /></div>`;' +
                    '});' +
                    'const printFrame = document.createElement("iframe");' +
                    'printFrame.style.position = "absolute";' +
                    'printFrame.style.width = "0";' +
                    'printFrame.style.height = "0";' +
                    'printFrame.style.border = "0";' +
                    'document.body.appendChild(printFrame);' +
                    'const frameDoc = printFrame.contentWindow.document;' +
                    'frameDoc.open();' +
                    'frameDoc.write(`<!DOCTYPE html><html><head><title>æ‰“å°</title><style>' +
                    '@page { size: A4; margin: 0; }' +
                    'body, html { margin: 0; padding: 0; width: 100%; height: 100%; }' +
                    'img { display: block; }' +
                    '</style></head><body>${printHtml}</body></html>`);' +
                    'frameDoc.close();' +
                    'setTimeout(() => {' +
                    'try {' +
                    'printFrame.contentWindow.focus();' +
                    'printFrame.contentWindow.print();' +
                    '} finally {' +
                    'document.body.removeChild(printFrame);' +
                    '}' +
                    '}, 500);' +
                    '}';


                const h =
                    '<!DOCTYPE html>' +
                    '<html>' +
                    '<head>' +
                    '<title>æ‰“å°é¢„è§ˆ</title>' +
                    '<style>' + s + '</style>' +
                    '</head>' +
                    '<body>' +
                    b +
                    '<script>' + script + '<\/script>' +
                    '</body>' +
                    '</html>';


                w.document.write(h);
                w.document.close();
                showStatus('å·²æ‰“å¼€å¤šé¡µæ‰“å°é¢„è§ˆçª—å£', 'success');




            } catch (error) {
                showStatus('é¢„è§ˆå¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
                console.error('Preview error:', error);
            }
        }

        // åˆ†é¡µæ§åˆ¶å‡½æ•°
        function prevPage() {
            if (currentPage > 0) {
                currentPage--;
                drawCurrentPage();
                updatePaginationButtons();
                updatePageInfo();
            }
        }

        function nextPage() {
            if (currentPage < totalPages - 1) {
                currentPage++;
                drawCurrentPage();
                updatePaginationButtons();
                updatePageInfo();
            }
        }

        function updatePaginationButtons() {
            document.getElementById('prevPageBtn').disabled = currentPage === 0;
            document.getElementById('nextPageBtn').disabled = currentPage === totalPages - 1;
        }

        function updatePageInfo() {
            document.getElementById('pageInfo').textContent = `ç¬¬ ${currentPage + 1} é¡µ / å…± ${totalPages} é¡µ`;
        }

        // æ¸…ç©ºç”»å¸ƒ
        function clearCanvas() {
            uploadedImages = [];
            uploadedPdfs = [];
            currentPdfFiles = [];
            currentPage = 0;
            totalPages = 1;
            initCanvas();
            updateImageInfo();
            exportBtn.disabled = true;

            previewBtn.disabled = true;
            mainFileInput.value = '';
            imageInput.value = '';
            pdfInput.value = '';
            document.getElementById('reprocessBtn').style.display = 'none';
            document.getElementById('paginationControls').style.display = 'none';
            updatePaginationButtons();
            updatePageInfo();
            showStatus('ç”»å¸ƒå·²æ¸…ç©º', 'info');
        }



        // å¤„ç†å›¾ç‰‡æ–‡ä»¶
        async function processImageFiles(files) {
            const remainingSlots = MAX_IMAGES_PER_PAGE * MAX_PAGES - uploadedImages.length;
            if (remainingSlots <= 0) {
                showStatus(`å·²è¾¾åˆ°æœ€å¤š${MAX_IMAGES_PER_PAGE * MAX_PAGES}ä¸ªæ–‡ä»¶çš„é™åˆ¶ã€‚å¦‚éœ€ç»§ç»­ï¼Œè¯·å…ˆæ¸…ç©ºç”»å¸ƒã€‚`, 'error');
                return;
            }

            if (files.length > remainingSlots) {
                showStatus(`æœ¬æ¬¡æœ€å¤šè¿˜èƒ½æ·»åŠ  ${remainingSlots} ä¸ªæ–‡ä»¶ï¼ˆæ€»è®¡ä¸è¶…è¿‡${MAX_IMAGES_PER_PAGE * MAX_PAGES}ä¸ªï¼‰`, 'info');
            }

            const filesToLoad = files.slice(0, Math.max(0, remainingSlots));
            const startIndex = uploadedImages.length; // è®°å½•æ–°å¢æ–‡ä»¶çš„èµ·å§‹ä¸‹æ ‡
            let loadedCount = 0;

            filesToLoad.forEach((file) => {
                const reader = new FileReader();
                reader.onload = function (event) {
                    const img = new Image();
                    img.onload = function () {
                        uploadedImages.push(img);
                        loadedCount++;

                        if (loadedCount === filesToLoad.length) {
                            // æ›´æ–°æ€»é¡µæ•°
                            totalPages = Math.ceil(uploadedImages.length / MAX_IMAGES_PER_PAGE);

                            // æ˜¾ç¤ºæˆ–éšè—åˆ†é¡µæ§ä»¶
                            const paginationControls = document.getElementById('paginationControls');
                            if (totalPages > 1) {
                                paginationControls.style.display = 'block';
                                updatePaginationButtons();
                                updatePageInfo();
                            }

                            // ç»˜åˆ¶å½“å‰é¡µå†…å®¹
                            drawCurrentPage();
                            updateImageInfo();
                            exportBtn.disabled = uploadedImages.length === 0;

                            previewBtn.disabled = uploadedImages.length === 0;
                            showStatus(`æˆåŠŸæ·»åŠ  ${filesToLoad.length} ä¸ªæ–‡ä»¶ï¼ˆå½“å‰å…± ${uploadedImages.length} ä¸ªï¼Œ${totalPages} é¡µï¼‰`, 'success');
                        }
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        // åˆå§‹åŒ–
        initCanvas();
        updateQualityInfo();
        updatePaginationButtons();
        updatePageInfo();
        
        // æ˜¾ç¤ºç”»å¸ƒåƒç´ ä¿¡æ¯
        const devicePixelRatio = window.devicePixelRatio || 1;
        console.log('è®¾å¤‡åƒç´ æ¯”:', devicePixelRatio);
        console.log('ç”»å¸ƒå®é™…å°ºå¯¸:', canvas.width, 'x', canvas.height);
        console.log('ç”»å¸ƒæ˜¾ç¤ºå°ºå¯¸:', canvas.style.width, 'x', canvas.style.height);
        
        showStatus('è¯·é€‰æ‹©è¦ä¸Šä¼ çš„æ–‡ä»¶ï¼ˆå›¾ç‰‡æˆ–PDFï¼Œæœ€å¤š30ä¸ªï¼‰');
    </script>
</body>

</html>